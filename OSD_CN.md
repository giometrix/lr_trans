3.9 调用约定与运行时堆栈
========
操作系统严重依赖于函数调用机制。应用程序需要通过函数调用来使用操作系统服务，因此可以认为函数调用定义了操作系统服务。此外，当将上下文从一个进程切换到另一个进程时，操作系统必须要合理地处理进程各自的函数嵌套调用的情况，因此操作系统设计者必须了解功能调用的细节。以下段落定义了与函数调用相关的关键概念和机制。

*调用约定* 调用约定是指程序在函数调用时传递参数和获取返回值所采取的步骤。之所以使用了*约定*这个术语，是因为硬件并没有描述所有的细节。硬件设计对可能使用的方法进行了一些限制，编译器的编写者可以最终决定具体使用的方法。操作系统在处理中断和线程切换的过程中调用了函数，因此它必须要理解并遵循与编译器相同的约定。

*参数与参数传递* 调用函数的时候，调用者提供了一组与形式参数相对应的实际参数。商业处理器已经实现了多种参数传递的方式。示例平台展示了两种常见的方法：将参数放置在堆栈中，或者传递给通用寄存器。

*运行时堆栈与堆栈帧内容* 静态作用于语言（譬如C语言）使用运行时堆栈来存储与函数调用有关的状态。编译器在堆栈中分配足够的空间来保存被调用函数的*激活记录*。所分配的空间称为*堆栈帧*。每条激活记录包含着与该函数关联的局部变量的空间、计算期间所需要的临时存储、返回地址以及其他杂项。我们假设堆栈从较高的内存地址下降到较低的内存地址。编译器生成为了创建堆栈帧所需的代码。编译器计算局部变量和辅助项目所需的大小。常见的辅助项目包括用于保存寄存器内容的临时空间。在上下文切换的过程中，原寄存器的值已经被保存到临时空间，因此调用函数可以使用这些寄存器，调用结束后只需要把寄存器恢复原始值即可。当创建一个新的进程时，操作系统需要为进程的初始化函数构造一个堆栈帧。因此，操作系统需要确切地知道堆栈帧的布局，包括参数的位置和返回地址。下面的例子将阐明这个概念，在示例中我们假设使用gcc编译器；其他编译器使用的调用约定可能会有所不同。

3.9.1  Galileo （Intel）
----------
在Intel处理器上调用函数之前，调用者将寄存器EAX、ECX和EDX压栈，接着把参数以逆序压栈，然后执行一个调用指令，这会将返回地址压入堆栈中。被调用函数把EBP、EBX、EDI和ESI压入堆栈，并把局部变量的空间压入栈。当调用返回时，这些值以逆序从栈中依次弹出。图3.4展示了在函数调用后的瞬间堆栈顶部的内容（提示：堆栈向下扩展）。

3.9.2  BeagleBone Black (ARM)
----------
在ARM处理器上，函数的前四个参数在寄存器a0-a3（即寄存器r0 - r4）中传递。除前四个外，其他参数将在栈上传递。要调用一个函数，调用者执行BL（分支和链接）指令。当BL执行时，硬件将返回地址放在寄存器r14中。被调用函数必须保存将使用的寄存器；通常，被调用的函数将r14-r4的副本压栈，然后把CPSR（状态）寄存器压栈。图3.5说明了在函数调用后的瞬间堆栈顶部的内容（提示：堆栈向下增长）。在图中，堆栈的顶部只包含超出前七个的局部变量空间。按照惯例，前七个局部变量存储在寄存器4至8、10和11中。
事实上，对于不同的ARM架构版本，其保存的寄存器集合也有所不同。此外，如果程序使用浮点数，则浮点寄存器也必须保存并恢复。

3.10中断和中断处理
==========
现代处理器提供允许外部I/O设备在需要服务时中断处理器的机制。在大多数情况下，处理器硬件具有紧密相关的异常机制，用于在发生错误或故障时通知软件（例如，应用程序尝试除零或引用存储器中不存在的虚存页面）。从操作系统的角度来看，中断至关重要，因为它允许处理器在I/O进行的同时进行计算。【脚注：†稍后的章节将介绍操作系统如何管理中断和异常处理，并显示用户执行的高级I/O操作与低级设备硬件机制的关系。】

连接到总线的任何I/O设备都可能在该设备需要服务时中断处理器。为此，设备将信号放在其中一条总线控制线上。在正常执行的“取指-执行”周期中，处理器中的硬件监控控制线，并在控制线已经发出信号时启动中断处理。以RISC处理器为例，主处理器通常不包含处理中断的硬件。取而代之的是，协处理器代表主处理器与总线进行交互。

无论处理器使用什么中断机制，硬件或操作系统必须保证：

- 处理器的整个状态（包括程序计数器和状态寄存器）在发生中断时被保存。
- 处理器运行适当的中断处理程序处理器，它在中断发生之前必须已经被放置在存储器中。
- 当中断完成时，操作系统和硬件提供恢复处理器整个状态并在中断点继续处理的机制。

中断引入了一个渗透整个操作系统的基本思想。中断可以在任何时候发生，而操作系统也可以在中断期间从一个进程切换到另一个进程，这意味着其他进程随时都可能执行。

为了防止由并发进程尝试操纵共享数据引起的问题，操作系统需要采取必要的措施避免上下文切换。防止其他进程执行的最简单的方法是禁用中断。硬件中包含了操作系统可以用来控制中断的中断屏蔽机制。在许多硬件系统上，如果中断掩码被赋值为零，则处理器将忽略所有中断；如果掩码被分配了非零值，则硬件允许发生中断。在某些处理器上，硬件对每个设备都有单独的中断位，而在其他处理器上，掩码提供了八级或十六级的集合，每个设备都被分配一个级。我们发现许多系统级函数在操纵全局数据结构和I/O队列时禁止中断。

3.11 向量中断
==========
当设备中断时，硬件如何知道处理中断的代码的位置？大多数处理器上的硬件使用称为向量中断的机制。其基本思想很简单：每个设备分配一个小的整数：0、1、2等等。整数称为中断级别号或中断请求号。操作系统创建一个内存中的指针数组，称为中断向量，其中中断向量数组中的第i个条目指向处理具有向量号i的器件中断的代码。当中断发生时，设备通过总线将其向量号发送到处理器。 根据处理器细节，硬件或操作系统使用向量号作为中断向量的索引，获取指针，并使用指针作为运行代码的地址。

由于中断向量必须在发生任何中断之前进行配置，操作系统必须在总线上分配设备地址的同时初始化中断向量。中断级别号的分配通常采用与地址分配相同的模式。手动分配意味着人们为每个设备分配唯一的中断级别号，然后相应地配置中断向量地址。自动方法需要总线和设备硬件，可以在运行时分配中断级别。要使用自动方法，操作系统在启动时对设备进行轮询，为每个设备分配唯一的中断级别号，并相应地初始化中断向量。自动分配相对来说更加安全（即不太容易发生人为错误），但在设备和总线中都需要更复杂的硬件支持。我们可以看到关于静态和自动中断向量分配的例子。

3.12 异常向量和异常处理
==========
许多处理器使用与中断处理相同的方法来处理异常。也就是说，每个异常被分配一个唯一的数字：0、1、2等等。当发生异常时，硬件将异常号放在寄存器中。操作系统提取异常号码，并将该号码作为寻找异常向量的索引。处理器硬件处理中断和异常的方式之间存在细微差别。我们认为，中断是在两个指令之间发生的，因此对于中断来说，一条指令已经完成，而下一条指令尚未开始。而异常是指一条指令运行过程中发生的问题。因此，在处理器从异常中返回的时候，程序计数器尚未累加，相应的指令可以重新执行。重新执行对缺页异常来说非常重要——当缺页发生时，操作系统必须从内存中读取丢失的页面，设置页表，然后再次执行引起缺页的指令。

3.13 时钟硬件
==========
除了传输数据的I/O设备之外，大多数计算机还包含了可用于管理定时事件的硬件。时钟硬件有两种基本的形式：

- 实时时钟
- 间隔计时器

*实时时钟* 实时时钟电路由定期产生脉冲（例如，每秒1000次）的硬件组成。要将实时时钟电路转化为实时时钟设备，需要把硬件配置为在每一个脉冲发生时都向处理器发送一个中断。实时时钟设备不保留任何计数器，不存储时间，并且无法调整周期（要调整脉冲频率，只能更换电路中的晶体）

*间隔计时器* 在概念上，间隔定时器包括实时时钟电路。实时时钟与计数器相连接，并以规则的间隔向计数器发送脉冲，这样计数器就可以记录其脉冲数。计数器又与一个比较电路相连接，比较电路把计数器的值与阈值进行比较。操作系统可以制定阈值，并且可以把计数器清零。当计数器达到阈值的时候，间隔计数器向处理器发送中断。间隔定时器在效率上具有优势，因为它可以配置为等到事件发生才中断处理器，而不是不停地向处理器发送中断。当然，间隔计时器的硬件比实时时钟复杂。

3.14 串行通信
==========
串行通信设备是最简单的I/O设备之一，它已经在计算机上应用了数十年。每个示例平台都包含用作系统控制台的RS-232串行通信设备。串行硬件既可以处理输入又可以处理输出（即字符的发送和接收）。当发生中断时，处理器检查设备硬件寄存器，以确定输出端是完成传输还是输入端已经接收到字符。第15章具体阐述串行设备，并展示了如何处理中断。

3.17 内存保护
==========
示例平台上可用的内存硬件包括操作系统可用于将一个进程与另一个进程保护起来的机制，并保护操作系统免受应用程序进程的影响。例如，应用程序可以配置为以用户模式运行，这意味着它们无法读取或写入内核内存。当应用程序进行系统调用时，控制转移到内核，并且权限级别增加到内核模式，直到调用返回。了解保护的关键是记住控制只能在操作系统设计者提供的特定入口点传送到操作系统。因此，设计人员可以确保应用程序仅接受精心控制的服务。

像许多其他嵌入式系统一样，我们的示例代码避免了内存保护的复杂性和运行时开销。代码完全以特权模式运行，没有内存保护。缺少保护意味着程序员必须小心，因为任何进程都可以访问任何内存位置，包括分配给操作系统结构的内存或分配给另一个进程的堆栈的内存。如果进程溢出分配的堆栈区域，则进程的运行时堆栈将覆盖另一进程的堆栈中的数据。
